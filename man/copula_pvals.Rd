% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/differential_analysis.R
\name{copula_pvals}
\alias{copula_pvals}
\title{Compute depletion or enrichment p-value given copula model.}
\usage{
copula_pvals(uv, copula.model, copula.tail = "upper.left")
}
\arguments{
\item{uv}{matrix of dimension n x 2 with U,V r.v. ~ Uniform(0,1), see \code{\link{VineCopula::pobs}} for generation of U,V from X,Y; here U,V matrix must be such that either U >= V (lower.right corner) or U <= V (upper.left corner)}

\item{copula.model}{object of class \code{\link{VineCopula::BiCop}}}

\item{copula.tail}{character indicating tail (corner) of copula to calculate cdf, either "upper.left" or "lower.right"}
}
\value{
numeric vector of p-value/s of length equal to \code{nrow(uv)}
}
\description{
Calculates p-value of enrichment or depletion of given point/s with u,v coordinates given copula F(U,V):
\itemize{
  \item{}{depletion probability is defined as: P(U < u, V > v) = F(U < u, V < 1) - F(U < u, V < v), so its upper left rectangle of copula distribution}
  \item{}{enrichment probability is defined as: P(U > u, V < v) = F(U < 1, V < v) - F(U < u, V < v), so its lower right rectangle of copula distribution}
}
NOTES:
\itemize{
  \item{}{copula is symmetric with respect to U = V}
  \item{}{enrichment is relative to condition u = F(X < x), in other words enriched means chromatin is enriched in interactions in conditon X comparing with Y}
  \item{}{P(U,V) distribution can be plotted as U horizontal and increasing from left (start at 0) to right (ends at 1) and V vertical and increasing from bottom (start at 0) to top (ends at 1)}
  \item{}{both uv and model is for single (and the same) diagonal}
  \item{}{uv must all be points for either top left (depletion) or bottom right (enrichment) part of distribution}
}
For calculation of copula cdf \code{\link{VineCopula::::BiCopCDF}} is used.
}
\examples{
library("copula")
library("MASS")
# make bivariate standard normal copula of highly correlated variables (0.8)
cop <- BiCop(1, 0.8)
# convert to package copula class --> for illustration purposes
cop.copula.object <- copulaFromFamilyIndex(cop$family, cop$par)
# illustrate copula
persp(cop.copula.object, dCopula) # 3D
contourplot2(cop.copula.object, dCopula, col.regions = terrain.colors) # 2D heatmap
# simulate sample of size 10000 and draw copula 2d density plot (heatmap)
sample.cop <- data.frame(rCopula(10000, cop.copula.object))
plot_copula_density(sample.cop) # 2D heatmap with ggplot
# now simulate sample from bivariate standard normal with much lower correlation than that of copula
sigma <- matrix(c(1, 0.4, 0.4, 1), nrow = 2)
xy <- mvrnorm(500, mu = c(0, 0), Sigma = sigma, empirical = T)
# convert X,Y to U,V ~ Uniform(0,1) using copula::pobs
uv <- pobs(xy)
# keep only upper V >= U (\\code{copula_pvals} calculates p-values separately for V >= U and U >= V)
uv <- uv[uv[,2] >= uv[,1],]
# illustrate observations on top of copula density
uv.df <- data.frame(uv)
colnames(uv.df) <- c("U","V")
plot_copula_density(sample.cop) + geom_point(aes(x = U, y = V), data = uv.df, size = 0.5)
# calculate p-values of observations given the copula model (use only )
uv.df$pval <- copula_pvals(uv, cop)
# convert to pvalues to negative log10(pval)
uv.df$neg.log.pval <- -log10(uv.df$pval)
# illustrate observations significance on top of copula model
plot_copula_density(sample.cop) + geom_point(aes(x = U, y = V, color = neg.log.pval), data = uv.df, size = 0.3) + scale_color_gradient(low = "yellow", high = "black", name = "-log10(pval)")
}
